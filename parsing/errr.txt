static int	error_pipe(t_node *token)
{
    int	last_pipe;

    if (token && token->type == 2)
    {
        printf("error\n");
        return (-1);
    }

    while (token)
    {
        if (token->type == 2 && token->next != NULL)
        {
            token = token->next;
            while (token->type == 1 && token->next != NULL)
                token = token->next;
            if (token->type == 2)
                return (ft_handl_error(NAME, "", ERR_PIPE), -1);
        }
        last_pipe = token->type;
        token = token->next; // Move to the next token
        if (!token)
        {
            if (last_pipe == 2)
                return (ft_handl_error(NAME, "", ERR_PIPE), -1);
        }
    }

        

    return (1);
}

static int	error_red(t_node *token)
{
	while (token)
	{
		if ((token->type == 3 || token->type == 4 || token->type == 5 || token->type == 6) && token->next == NULL)
			return (ft_handl_error(NAME, ERR_FILE, token->content), -1);
		if ((token->type == 3 || token->type == 4 || token->type == 5|| token->type == 6) && token->next != NULL)
		{
			token = token->next;
			while (token->type == 1 && token->next != NULL)
				token = token->next;
			if (token->type != 9 )//&& token->type != SIGN && token->type != EXIT_STATUS)
				return (ft_handl_error(NAME, ERR_FILE, token->content), -1);
		}
		token = token->next;
	}
	return (1);
}
int parsing(t_node *head)
{
    
    if(error_pipe(head) == -1)
        return(-1);
    if(error_red(head) == -1)
        return(-1);
    return(1);
}

// handle herdoc
int handle_herdoc(char *delimiter) 
{
    char *line;
    int temp_fd;

    // Open or create "temp.txt" for appending
    temp_fd = open("temp.txt", O_RDWR | O_CREAT | O_TRUNC, 0644);
    if (temp_fd == -1) {
        perror("Error creating temporary file");
        exit(0);
    }

    while (1) {
        line = readline("heredoc> ");
        if (line == NULL)
            break;

        // Check for the delimiter at the start of the line
        if (strncmp(line, delimiter, strlen(delimiter)) == 0 && line[strlen(delimiter)] == '\0') {
            free(line);
            break; // Exit loop when delimiter is found
        }

        // Write the line and newline character to the temporary file
        if (write(temp_fd, line, strlen(line)) == -1) {
            perror("Error writing to temporary file");
            free(line);
            close(temp_fd);
            exit(0);
        }
        if (write(temp_fd, "\n", 1) == -1) {
            perror("Error writing to temporary file");
            free(line);
            close(temp_fd);
            exit(0);
        }

        free(line);
    }

    // Close the temporary file after writing
    close(temp_fd);
    temp_fd = open("temp.txt", O_RDONLY, 0644);
    if (temp_fd == -1) {
        perror("Error opening temporary file for reading");
        exit(0);
    }
    int my_fd = temp_fd;
    close(temp_fd);
    if (unlink("temp.txt") == -1) {
        perror("Error removing temporary file");
        exit(0);
    }
    return(my_fd);
}
void handle_herddoce(t_command **command)
{
    t_command *first = *command;
    while(first != NULL)
    {
        int i = 0;
        while(first->arg[i])
        {
            if(strcmp(first->arg[i],"<<") == 0)
            {
                //printf("#%s#\n",first->arg[i + 1]);
                if(first->arg[i + 1])
                    first->my_fd = handle_herdoc(first->arg[i + 1]);
                    
            }
            i++;
        } 
        first = first->next;
    }
}